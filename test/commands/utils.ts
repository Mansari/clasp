// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utility functions for testing `clasp` commands.
 * This module primarily provides the `runCommand` function, which executes
 * `clasp` commands programmatically and captures their output and exit status,
 * facilitating integration testing of command behavior.
 */

import {CommanderError} from 'commander';
import {makeProgram} from '../../src/commands/program.js';

/**
 * Represents the captured result of executing a `clasp` command via `runCommand`.
 */
export interface CommandResult {
  /** Captured standard output (stdout) from the command. */
  stdout: string;
  /** Captured standard error (stderr) from the command. */
  stderr: string;
  /** The exit code of the command (0 for success, non-zero for errors). */
  exitCode: number;
  /** Any error message generated by commander if an error occurs during its processing. */
  message: string;
}

// A unique sentinel object used to identify if an error was thrown by commander's exitOverride.
// This helps differentiate commander's controlled exits (like for --help) from unexpected errors.
const EXIT_SENTINEL = new String('CommanderExitSentinel'); // Use String object for unique reference

/**
 * Executes a `clasp` command programmatically and captures its output and exit status.
 * This is a helper function for integration tests.
 *
 * @param args An array of strings representing the command and its arguments (e.g., `['login', '--no-localhost']`).
 * @param passthrough If true (default), allows stdout/stderr to also pass through to the console during test execution.
 *                    Set to false to completely silence the command's output during tests.
 * @returns A Promise that resolves to a `CommandResult` object containing the command's output and status.
 */
export async function runCommand(args: string[], passthrough = true): Promise<CommandResult> {
  // Store original stdout/stderr write methods to restore them later.
  const originalStdoutWrite = process.stdout.write;
  const originalStderrWrite = process.stderr.write;

  // Initialize the result object to capture command outputs.
  const result: CommandResult = {
    stdout: '',
    stderr: '',
    exitCode: 0, // Default to success
    message: '',
  };

  // Override process.stdout.write to capture stdout.
  process.stdout.write = (chunk: unknown, ...restArgs: any[]): boolean => {
    if (typeof chunk === 'string') {
      result.stdout += chunk;
    }
    if (passthrough) {
      return originalStdoutWrite.call(process.stdout, chunk, ...restArgs);
    }
    return true;
  };

  // Override process.stderr.write to capture stderr.
  process.stderr.write = (chunk: unknown, ...restArgs: any[]): boolean => {
    if (typeof chunk === 'string') {
      result.stderr += chunk;
    }
    if (passthrough) {
      return originalStderrWrite.call(process.stderr, chunk, ...restArgs);
    }
    return true;
  };

  // Create the main commander program instance with an exit override.
  // The exitOverride allows capturing commander's exit behavior (e.g., for --help or errors)
  // without actually terminating the test process.
  const claspProgram = makeProgram((err: CommanderError) => {
    // This callback is invoked by commander when it would normally exit.
    if (err) {
      result.exitCode = err.exitCode || 1; // Use commander's exit code or default to 1 for errors.
      result.message = err.message ?? '';   // Capture any error message from commander.
    }
    // Throw the sentinel to signal a commander-controlled exit.
    // This is caught by the try/catch block below.
    throw EXIT_SENTINEL;
  });

  try {
    // Simulate command line execution by parsing the provided arguments.
    // 'node' and 'index.js' are placeholders for `process.argv[0]` and `process.argv[1]`.
    await claspProgram.parseAsync(['node', 'index.js', ...args]);
  } catch (error) {
    // If the error is not our sentinel, it's an unexpected error.
    if (error !== EXIT_SENTINEL) {
      result.exitCode = 1; // Mark as failure.
      result.stderr += `Unexpected error during command execution: ${error instanceof Error ? error.message : String(error)}\n`;
      if (passthrough) {
        console.error('Unexpected error in runCommand:', error);
      }
    }
    // If it is the EXIT_SENTINEL, it means commander handled the exit (e.g. printed help, version, or an error message),
    // and result.exitCode and result.message would have been set by the exitOverride callback.
  } finally {
    // Restore original stdout/stderr write methods.
    process.stdout.write = originalStdoutWrite;
    process.stderr.write = originalStderrWrite;
  }

  return result;
}
